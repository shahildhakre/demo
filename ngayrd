import os
import shutil
from pathlib import Path
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langgraph.graph import StateGraph, END
from langchain_groq import ChatGroq
from pydantic import BaseModel, Field
from typing import Optional, List

# Define the state
class GraphState(BaseModel):
    srs_content: Optional[str] = Field(default=None)
    project_structure: Optional[dict] = Field(default=None)
    generation_complete: bool = Field(default=False)
    errors: List[str] = Field(default_factory=list)

# Initialize LLM
llm = ChatGroq(
    temperature=0,
    model_name="llama3-70b-8192",
    api_key=os.environ.get("GROQ_API_KEY")
)

# Load SRS document
def load_srs(state: GraphState) -> GraphState:
    srs_path = Path("srs.txt")
    if not srs_path.exists():
        state.errors.append("SRS document not found.")
        return state
    
    with open(srs_path, "r") as f:
        state.srs_content = f.read()
    
    return state

# Generate project structure
def generate_structure(state: GraphState) -> GraphState:
    if not state.srs_content:
        state.errors.append("No SRS content loaded.")
        return state
    
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a software architect. Based on the provided SRS document, define a structured folder layout for a FastAPI project. Return JSON format with directories and files.")
    ])
    
    chain = prompt | llm | StrOutputParser()
    response = chain.invoke({"srs": state.srs_content})
    
    import json
    try:
        state.project_structure = json.loads(response)
    except json.JSONDecodeError:
        state.errors.append("Failed to parse project structure response.")
    
    return state

# Create project files
def create_project(state: GraphState) -> GraphState:
    if not state.project_structure:
        state.errors.append("No project structure available.")
        return state
    
    base_dir = Path("generated_fastapi_project")
    if base_dir.exists():
        shutil.rmtree(base_dir)
    base_dir.mkdir()
    
    for directory, files in state.project_structure.items():
        dir_path = base_dir / directory
        dir_path.mkdir(parents=True, exist_ok=True)
        
        for file, content in files.items():
            file_path = dir_path / file
            with open(file_path, "w") as f:
                f.write(content)
    
    state.generation_complete = True
    return state

# Build the workflow
def build_graph():
    workflow = StateGraph(GraphState)
    workflow.add_node("load_srs", load_srs)
    workflow.add_node("generate_structure", generate_structure)
    workflow.add_node("create_project", create_project)
    
    workflow.add_edge("load_srs", "generate_structure")
    workflow.add_edge("generate_structure", "create_project")
    workflow.add_edge("create_project", END)
    
    return workflow.compile()

# Run the workflow
def run_generation():
    graph = build_graph()
    initial_state = GraphState()
    final_state = graph.invoke(initial_state)
    
    if final_state.errors:
        print("Errors:", final_state.errors)
    else:
        print("Project generated successfully!")

if __name__ == "__main__":
    run_generation()

# Node to create and activate virtual environment
def setup_virtual_environment(state: GraphState) -> GraphState:
    try:
        if not state.project_path:
            state.errors.append("Project path not set.")
            return state
        
        project_root = Path(state.project_path)
        venv_path = project_root / "venv"
        
        # Create virtual environment
        subprocess.run(["python", "-m", "venv", str(venv_path)], check=True)
        
        # Determine activation command based on OS
        activate_script = venv_path / "Scripts" / "activate" if os.name == "nt" else venv_path / "bin" / "activate"
        
        # Install dependencies
        subprocess.run([str(venv_path / "bin" / "pip"), "install", "-r", str(project_root / "requirements.txt")], check=True)
        
        state.dependencies_installed = True
    except Exception as e:
        state.errors.append(f"Error setting up virtual environment: {str(e)}")
    return state
